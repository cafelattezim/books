### 리엔지니어링 프로젝트에서 초기 이해의 중요성
소프트웨어 시스템을 리엔지니어링할 때, 첫 만남(First Contact) [(39쪽)] 이후 시스템과 사용자에 대한 감이 잡히기 시작한다. 어떤 기능이 중요한지, 그리고 왜 반드시 복구해야 하는지도 알게 된다. 

하지만 전체적인 설계를 파악하지 못한 상태에서는 해당 기능을 기존 시스템에서 분리할 수 있을지, 그리고 얼마나 많은 노력이 필요할지 예측하기 어렵다.

이러한 초기 이해는 프로젝트의 성공을 위해 필수적이며, 이 장에서는 그 방법을 설명한다.

### 초기 아이디어를 구체화하고 문서화하기
**첫 만남(First Contact)**에서 얻은 정보는 시스템에 대한 첫인상을 형성하는 데 도움이 된다. 이제 이를 발전시켜 구체적인 이해를 정리하고 문서화해야 한다. 이렇게 해야 이후의 리버스 엔지니어링(reverse engineering) 과정에서 참고할 수 있으며, 프로젝트 진행의 기반이 된다.

이 단계에서 가장 중요한 것은 다음과 같다. 

- 프로젝트의 신뢰할 수 있는 기초 마련하기 
- 발견한 내용을 정확히 기록하고 체계적으로 정리하기 

### 문서화 방식: 프로젝트 규모에 맞추기
* 대규모 프로젝트(10명 이상의 개발자 참여)
  * 표준 문서 템플릿과 형상 관리 시스템(Configuration Management System)이 필요하다.
* 소규모 프로젝트(3명 이하의 개발자 참여)
  * 중앙 서버에서 공유하는 단순한 파일만으로도 충분할 수 있다.

그러나 프로젝트의 크기와 관계없이 항상 고려해야 할 중요한 요소들이 있다.

### 리버스 엔지니어링에서 꼭 고려해야 할 4가지 요소
1. 데이터는 오해를 불러올 수 있다.
   * 기존 시스템을 이해하려면 데이터를 수집하고 분석해야 한다.
   * 하지만 데이터를 해석하는 방법은 여러 가지이며, 근거 없는 가정이 개입될 수도 있다.
   * 출처를 이중으로 확인하여 신뢰할 수 있는 기반을 마련해야 한다.
2. 이해는 반복적인 과정이다.

   * 사람의 두뇌는 학습을 통해 이해를 발전시킨다.
   * 리버스 엔지니어링도 이에 맞춰 유연하고 반복적인 탐색을 허용해야 한다.
   * 반드시 반복(iteration)과 피드백 루프를 계획하여 학습 과정을 촉진해야 한다.
3. 지식은 공유되어야 한다.
   * 시스템을 이해한 후에는 반드시 동료들과 공유해야 한다.
   * 그래야 팀원들도 업무를 효율적으로 수행할 수 있고, 피드백을 통해 이해도를 개선할 수 있다.
   * 팀 조직과 업무 방식에 맞춰 정보를 공유해야 한다.
   * 예를 들어, 팀 회의에서 발표하거나, 커피 머신 옆 벽에 큰 다이어그램을 붙이는 것도 좋은 방법이 될 수 있다.
4. 팀 간 원활한 의사소통이 핵심이다.
   * 시스템을 이해하고 문서화하는 것이 목적이 아니다.
   * 실제 목표는 팀원들과 효과적으로 소통하는 것이다.
   * 팀원들이 이해할 수 있는 방식으로 문서화해야 한다.
   * UML 클래스 다이어그램을 그려도 팀원들이 읽을 수 없다면 무의미하다.
   * 사용 사례(use case)를 작성해도 최종 사용자가 이해하지 못하면 무용지물이다.
   * 정보를 정리할 때는 상대방이 이해할 수 있는 언어와 방식을 선택하는 것이 가장 중요하다.
   
   
### 소프트웨어 시스템의 초기 이해 방법
소프트웨어 시스템을 처음 분석할 때, 잘못된 정보가 가장 큰 문제다. 따라서 신뢰할 수 있는 유일한 정보원인 소스 코드를 기반으로 분석해야 한다.

소스 코드를 분석하는 방법에는 두 가지 접근 방식이 있다.

##### (1) 상향식(bottom-up) 접근법

소스 코드에서 출발하여 중요한 정보를 걸러내고, 이를 상위 개념으로 정리하는 방식이다.
Analyze the Persistent Data와 Study the Exceptional Entities가 이 방법을 따른다.

##### (2) 하향식(top-down) 접근법

시스템의 상위 개념을 먼저 설정한 후, 이를 소스 코드와 비교하여 검증하는 방식이다.
Speculate about Design이 이 방법을 따른다.
실제로는 두 접근법을 병행해야 하지만, 구분해 두는 것이 도움이 된다.

### 분석 패턴 적용 순서
패턴을 적용하는 순서는 정해져 있지 않다. 일반적으로 다음과 같은 흐름을 따를 수 있다.

##### Analyze the Persistent Data
데이터베이스를 분석하여 시스템의 구조를 이해한다.

##### Speculate about Design
상위 개념을 설정하고 데이터 분석 결과를 반영하여 설계를 추론한다.

##### Study the Exceptional Entities
예외적인 요소들을 조사하여 설계의 특이점을 파악한다.

그러나 모든 시스템이 데이터베이스를 포함하는 것은 아니므로, 필요에 따라 `Speculate about Design`을 먼저 수행할 수도 있다. 
또한, 설계 추론이 어렵다면 `Study the Exceptional Entities`부터 시작하여 초기 가설을 수립하는 것도 가능하다.

각 패턴을 적용하는 데 걸리는 시간은 프로젝트 목표에 따라 다르다. 
기본적으로 각 패턴은 여러 번 반복적으로 적용해야 하며, 몇 번의 반복이 필요한지는 사전에 예측할 수 없다. 충분한 이해가 이루어졌는지는 패턴을 적용한 후에만 판단할 수 있다. 
따라서 패턴은 상황에 따라 유연하게 적용해야 한다.

다음 단계
소프트웨어 시스템에 대한 이해가 깊어지면, 이를 프로젝트 계획에 반영해야 한다.

`Analyze the Persistent Data와 Speculate about Design`의 결과는 기회(Opportunities) 항목에 추가한다.
`Study the Exceptional Entities`에서 발견한 문제 요소는 위험(Risks) 항목에 포함한다.
기초적인 이해가 완료되면, 프로젝트에 중요한 구성 요소들을 더 구체적으로 분석해야 한다. **Detailed Model Capture [p. 117]**에 설명된 기법들이 이를 수행하는 데 도움이 될 수 있다.

### 4.1 지속적인 데이터 분석
#### 의도
데이터베이스 시스템을 분석하여 가치 있는 객체 구조를 식별하고 유지해야 할 데이터를 파악한다.

#### 문제
어떤 객체 구조가 중요한 데이터를 나타내는지 식별하는 것이 핵심이다.

이 문제는 다음과 같은 이유로 어렵다.

* 중요한 데이터는 외부 저장소(파일 시스템, 데이터베이스 등)에 안전하게 저장해야 하지만, 이러한 저장소는 정리되지 않고 불필요한 데이터가 많을 수 있다.
* 메모리에 로드된 데이터는 복잡한 객체 구조를 가진다. 그러나 외부 저장소에서 제공하는 데이터 구조와 메모리 내 객체 구조 사이에는 큰 차이가 있다. 
  * 예를 들어, 레거시 데이터베이스에서는 상속 관계가 명확히 드러나지 않는다.
* "중요한 데이터"라는 개념은 상대적이며, 저장된 데이터의 상당 부분이 특정 리엔지니어링 프로젝트에 불필요할 수 있다.

그러나 다음과 같은 이유로 문제를 해결할 수 있다.

* 소프트웨어 시스템은 데이터를 지속적으로 저장하기 위해 데이터베이스를 사용하므로, 데이터베이스 스키마를 통해 저장된 데이터의 정적 구조를 분석할 수 있다.
* 데이터베이스에는 내부 객체를 조사할 수 있는 도구가 제공되므로, 기존 데이터를 활용하여 분석을 세밀하게 조정할 수 있다.
* 구현 언어의 데이터 구조를 데이터베이스 스키마로 매핑한 경험이 있기 때문에, 데이터베이스 스키마를 기반으로 클래스 다이어그램을 재구성할 수 있다.
* 시스템의 기능과 프로젝트의 목표를 어느 정도 이해하고 있기 때문에, 데이터베이스에서 중요한 부분을 식별할 수 있다.

#### 해결 방법
데이터베이스 스키마를 분석하여 가치 있는 데이터 구조를 추출하고, 이를 클래스 다이어그램으로 변환하여 팀 전체가 공유할 수 있도록 문서화한다.

#### 단계
이 과정은 일반적으로 관계형 데이터베이스를 대상으로 하지만, 다른 유형의 데이터베이스에서도 일부 단계는 적용할 수 있다. 이 단계를 반복적으로 수행하며 직관과 피드백을 활용해야 한다.

#### A. 준비 단계
초기 모델을 생성하여 관계형 데이터베이스 스키마를 클래스 다이어그램으로 변환한다. 소프트웨어 도구를 사용할 수도 있지만, 간단한 경우 종이 카드 등을 활용할 수도 있다.

1. 테이블 나열
   * 모든 테이블 이름을 나열하고, 각 테이블을 동일한 이름의 클래스로 생성한다.
2. 컬럼 분석
   * 각 테이블의 모든 컬럼을 수집하여 해당 클래스의 속성으로 추가한다.
3. 기본 키 식별
   * 기본 키 후보를 찾는다. 데이터베이스 스키마에서 직접 확인할 수 있지만, 보다 정밀한 분석이 필요할 수도 있다.
   * 모든 고유(UNIQUE) 인덱스를 조사하고, "ID" 또는 "#"과 같은 명명 규칙을 활용하여 기본 키를 추정한다.
   * 데이터 샘플을 수집하여 키가 실제로 유일한지 확인한다.
4. 외래 키 분석
   * 테이블 간의 외래 키 관계를 수집하여 클래스 간의 연관 관계를 생성한다.
   * 외래 키가 명시적으로 지정되지 않은 경우, 컬럼 타입과 명명 규칙을 기반으로 관계를 추론해야 한다.
   * 주의해야 할 사항
     * 동음이의어(homonym): 동일한 컬럼명과 데이터 타입을 가졌지만 의미가 다를 수 있음
     * 이의어(synonym): 서로 다른 컬럼명이나 데이터 타입을 가졌지만 의미는 같을 수 있음
     * 이를 해결하기 위해 인덱스, 뷰 선언, SQL 조인문을 확인하고, 데이터 샘플을 조사하여 외래 키 관계를 확정한다.

#### B. 상속 관계 적용
이전 단계에서는 관계형 데이터베이스의 테이블을 클래스 형태로 변환했지만, 관계형 데이터베이스는 상속(Inheritance) 을 직접 표현하지 못한다. 따라서 외래 키를 기반으로 상속 관계를 추론해야 한다.

1. 일대일 상속(One-to-One, Rolled Up Table) 확인

   * 어떤 테이블의 기본 키가 외래 키로서 다른 테이블을 참조하는 경우, 이 관계가 상속을 나타낼 가능성이 높다.
   * 해당 테이블에서 수행된 SELECT 문을 확인하여, 일반적으로 외래 키와 함께 조회되는지 확인한다.
   * 테이블 이름과 소스 코드를 분석하여 이 관계가 실제 상속인지 검증한다.
   * 상속으로 확인되면 연관 관계를 상속 관계로 변경한다.

2. 롤다운 상속(Rolled Down Table) 확인

   * 여러 테이블에서 동일한 속성들이 반복되는 경우, 이는 상속 계층이 여러 테이블로 나뉜 것일 수 있다.
   * 공통 속성을 가지는 테이블들을 그룹화하여 상위 클래스(Superclass) 를 생성하고, 속성을 상위 클래스로 이동한다.
   * 소스 코드를 확인하여 적절한 클래스 이름을 지정한다.

3. 롤업 상속(Rolled Up Table) 확인

   * 하나의 테이블이 많은 속성을 포함하고 있으며, 다수의 선택적 속성을 가지고 있다면, 해당 테이블이 여러 서브 클래스를 포함하고 있을 가능성이 있다.
   * SELECT 문에서 특정 컬럼 집합만 조회하는 경우, 이를 기반으로 클래스를 분리한다.
   * 테이블에 "종류(kind)"와 같은 열이 있는 경우, 해당 값을 활용하여 서브 클래스를 나눌 수 있다.

3. 연관 관계 보완
   * 데이터베이스에서 추출한 클래스 다이어그램이 완전하지 않을 수 있으므로, 소스 코드와 비교하여 연관 관계를 보완해야 한다.

#### C. 연관 클래스(Association Class) 확인

다대다(Many-to-Many) 관계를 나타내는 테이블을 찾는다.
두 개 이상의 외래 키로 이루어진 테이블은 연관 클래스로 변환할 가능성이 높다.

1. 중복된 연관 관계 병합
   * 어떤 클래스 A가 클래스 B를 참조하고, 반대로 클래스 B도 클래스 A를 참조하는 경우, 이를 양방향 연관 관계로 병합한다.
2. 외래 키 대상 해결
   * 테이블이 상속 관계로 인해 분해된 경우, 원래의 외래 키 대상이 모호해질 수 있다.
   * 데이터 샘플과 SQL 문을 분석하여 올바른 외래 키 대상을 결정한다.
3. 한정된 연관 관계(Qualified Association) 확인
   * 외래 키 외에도 특정 값을 함께 사용하여 조회하는 테이블을 찾는다.
   * 예를 들어, 정렬된 1:N 관계에서는 정렬 순서를 나타내는 컬럼이 존재할 수 있다.
   * 연관 관계의 다중성(Multiplicity) 확인
   * 모든 연관 관계는 기본적으로 선택적(옵셔널) 1:N 관계로 간주한다.
   * 그러나 NOT NULL 제약 조건, 인덱스, 데이터 샘플을 분석하면 보다 정확한 최소/최대 다중성을 확인할 수 있다.

#### D. 검증 단계
데이터베이스 스키마만으로 완전한 클래스 다이어그램을 추출하는 것은 어렵다. 다행히 레거시 시스템에는 데이터가 포함된 데이터베이스와 이 데이터를 처리하는 프로그램이 존재한다. 따라서 데이터 샘플과 SQL 문을 활용하여 분석을 검증해야 한다.
